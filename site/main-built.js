(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/primo/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/primo/package.json"
));

require.define("/node_modules/primo/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Entity = require('./lib/entity')\nvar Game = require('./lib/game')\n\nmodule.exports = {\n  DefineEntity: Entity.Define,\n  Create: function(targetId) {\n    return new Game(targetId)\n  }\n\n}\n\n//@ sourceURL=/node_modules/primo/index.js"
));

require.define("/node_modules/primo/lib/entity.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore') \nvar util = require('primo-utils')\nvar Eventable = require('primo-events')\n\nvar Entity = function(id,data, scene) {\n  Eventable.call(this)\n  this.id = id\n  data = data || {}\n  this.x = util.valueOrDefault(data.x, 0)\n  this.y = util.valueOrDefault(data.y, 0)\n  this.rotation = 0\n  this.lastx = this.x\n  this.lasty = this.y\n  this.velx = util.valueOrDefault(data.velx, 0)\n  this.vely = util.valueOrDefault(data.vely, 0)\n  this.rotvel = util.valueOrDefault(data.rotvel, 0)\n  this.width = util.valueOrDefault(data.width, 0)\n  this.height = util.valueOrDefault(data.height, 0)\n  this.gravible = false\n  this.scene = scene\n  this.game = scene.game\n  this.components = []\n  this.commandHandlers = {}\n  this.dispatch = _.bind(this.dispatch, this)\n}\n\nEntity.prototype = {\n  attach: function(component) {\n    this.components.push(component)\n    return component\n  },\n  tick: function(frameTime) {\n    this.raise('tick', frameTime)\n    _(this.components).each(function(c) { if(c.tick) c.tick(frameTime) })\n    this.checkAgainstLevel()\n  },\n  render: function(context) {\n    _(this.components).each(function(c) { if(c.render) c.render(context) })\n  },\n  handle: function(command, cb) {\n    this.commandHandlers[command] = cb\n  },\n  dispatch: function(command, data) {\n    var handler = this.commandHandlers[command]\n    if(!handler)\n      console.warn('No handler registered for command', command)\n    else\n      handler(data)\n  },\n  applyPhysics: function(frameTime) {\n    this.scene.applyGravityTo(this)\n    this.lastx = this.x\n    this.lasty = this.y\n    this.x += this.velx * frameTime\n    this.y += this.vely * frameTime\n    this.rotation += this.rotvel * frameTime\n    this.scene.applyGravityTo(this)\n  },\n  checkAgainstLevel: function() {\n    if(!this.scene.level) return\n    var level = this.scene.level\n\n    var res = level.checkQuadMovement(\n      this.x, this.y, this.width, this.height, \n      this.velx * this.frameTime, this.vely * this.frameTime)\n\n    if(res.horizontal && res.vertical) {\n      this.x = res.x\n      this.y = res.y\n      this.velx = 0\n      this.vely = 0\n    }\n    else if(res.horizontal) {\n      this.vely = 0\n      this.y = res.y\n    } \n    else if(res.vertical) {\n      this.velx = 0\n      this.x = res.x\n    }\n    else if(res.collision) {\n      this.x = res.x\n      this.y = res.y\n      this.velx = 0\n      this.vely = 0\n    }\n  },\n  kill: function() {\n    this.raise('killed')\n    this.scene.removeEntity(this)\n  }\n}\n\nEntity.Define = function(init, methods) {\n  var Ctor = function(id, data, game) {\n    Entity.call(this, id, data, game)\n    init.call(this, id, data)\n  }\n  _.extend(Ctor.prototype, Entity.prototype)\n  if(methods)\n    _.extend(Ctor.prototype, methods)\n  return Ctor\n}\n_.extend(Entity.prototype, Eventable.prototype)\n\nmodule.exports = Entity\n\n//@ sourceURL=/node_modules/primo/lib/entity.js"
));

require.define("/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/underscore/package.json"
));

require.define("/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo-utils/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"commons.js\"}\n//@ sourceURL=/node_modules/primo-utils/package.json"
));

require.define("/node_modules/primo-utils/commons.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\n  valueOrDefault: function(value, def) {\n    return typeof value !== 'undefined' ? \n         value : \n         def\n  }\n}\n\n//@ sourceURL=/node_modules/primo-utils/commons.js"
));

require.define("/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo-events/eventcontainer.js"
));

require.define("/node_modules/primo/lib/game.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar Timer = require('primo-timer')\n\nvar _ = require('underscore')\n\nvar Scene = require('./scene')\nvar Resources = require('./resources')\nvar Input = require('./input')\n\nvar Game = function(targetId) {\n  Eventable.call(this)\n  this.targetid = targetId\n  this.desiredFps = 30\n  this.cellsize = 32\n  this.gravity = function() {}\n  this.frameTime = 1 / this.desiredFps\n  this.tickTimer = new Timer(this.desiredFps)\n  this.tick = _.bind(this.tick, this)\n  this.canvas = document.getElementById(this.targetid)\n  this.context = this.canvas.getContext('2d')\n  this.scene = new Scene(this)\n  this.resources = new Resources()\n  this.input = new Input(this.canvas)\n}\n\nGame.prototype = {\n  reset: function() {\n    this.scene.reset()\n    this.tickTimer.clearSchedule()\n  },\n  start: function() {\n    this.raise('init')\n    setInterval(_.bind(this.doTick, this), this.frameTime * 1000)\n  },\n  doTick: function() {\n    this.tickTimer.tick(this.tick)\n    this.render()\n  },\n  tick: function() {\n    this.raise('PreTick', this.frameTime) \n    this.scene.tick(this.frameTime)\n    this.raise('PostTick', this.frameTime) \n  },\n  render: function() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.scene.render(this.context)\n    this.raise('render', this.context)\n  },\n  scheduleEvent: function(ev, ms) {\n    this.tickTimer.schedule(ev, ms)\n  }\n}\n\n_.extend(Game.prototype, Eventable.prototype)\n\nmodule.exports = Game\n\n//@ sourceURL=/node_modules/primo/lib/game.js"
));

require.define("/node_modules/primo/node_modules/primo-timer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"timer.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/package.json"
));

require.define("/node_modules/primo/node_modules/primo-timer/timer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n\nvar Timer = function(desiredFps) {\n  this.timeAtLastFrame = new Date().getTime()\n  this.idealTimePerFrame = 1000 / desiredFps\n  this.leftover = 0\n  this.scheduled = []\n  this.ticks = 0\n}\n\nTimer.prototype = {\n  tick: function(cb) {\n    var timeAtThisFrame = new Date().getTime()\n      , timeSinceLastTick = timeAtThisFrame - this.timeAtLastFrame + this.leftover\n      , catchUpFrameCount = Math.floor(timeSinceLastTick / this.idealTimePerFrame)\n\n    for(var i = 0; i < catchUpFrameCount; i++) {\n      cb()\n      this.ticks++\n      this.fireAnyScheduledEvents()\n    }\n\n    this.leftover = timeSinceLastTick - (catchUpFrameCount * this.idealTimePerFrame)\n    this.timeAtLastFrame = timeAtThisFrame\n  },\n  schedule: function(cb, ms) {\n    this.scheduled.push({\n      cb: cb,\n      ticks: this.ticks + Math.floor((ms / this.idealTimePerFrame))\n    })\n  },\n  clearSchedule: function() {\n    this.scheduled.length = 0\n  },\n  fireAnyScheduledEvents: function() {\n    var remaining = []\n    for(var i =0 ; i < this.scheduled.length; i++) {\n      var item = this.scheduled[i]\n      if(item.ticks <= this.ticks)\n        item.cb()\n      else\n        remaining.push(item)\n    }\n    this.scheduled = remaining\n  }\n}\n\nmodule.exports = Timer\n\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/timer.js"
));

require.define("/node_modules/primo/lib/scene.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar Eventable = require('primo-events')\nvar Camera = require('primo-camera')\nvar Level = require('./level')\n\nvar Scene = function(game) {\n  Eventable.call(this)\n  this.level = null\n  this.entities = []\n  this.layers = []\n  this.game = game\n  this.context = this.game.context\n  this.camera = new Camera(this.context)\n  this.camera.makeTopLeftWorldCoords(0,0)\n  this.gravityObject = {x: 0, y: 0}\n}\n\nScene.prototype = {\n  tick: function(frameTime) {\n    for(var i = 0; i < this.entities.length; i++) { \n      var entity = this.entities[i] \n      entity.tick(frameTime)\n      entity.applyPhysics(frameTime)\n    }\n  },\n  applyGravityTo: function(entity) {\n    if(!entity.gravible) return\n    this.gravityObject.x = 0\n    this.gravityObject.y = 0\n    this.game.gravity(entity, this.gravityObject)\n    entity.velx += this.gravityObject.x\n    entity.vely += this.gravityObject.y\n  },\n  render: function(context) {\n    this.camera.begin()\n    try {\n      if(this.level)\n        this.level.forEachLayer(_.bind(this.renderLayer, this))\n      this.forEachVisibleEntity(function(entity) {\n        entity.render(context)\n      })\n    }\n    catch(ex) {\n      console.log(\"problem rendering scene\", ex)\n    }\n    finally {\n      this.camera.end()\n    }\n  },\n  loadLevel: function(path) {\n    this.level = new Level(this, path)\n    this.level.on('loaded', this.onLevelLoaded, this)\n  },\n  setLevel: function(level) {\n    this.level = level\n    this.level.loadIntoScene(this)\n  },\n  onLevelLoaded: function() {\n    this.level.loadIntoScene(this)\n  },\n  reset: function() {\n    this.entities = []\n    this.clearListeners()\n    this.layers = []\n  },\n  findEntityById: function(id) {\n    return _.find(this.entities, function(entity) { return entity.id === id })\n  },\n  spawnEntity: function(Type, data)  {\n    var entity = new Type('entity-' + this.entities.length, data, this)\n    this.entities.push(entity)\n    entity.addProxy(this)\n    return entity\n  },\n  forEachEntity: function(cb) {\n    for(var i = 0; i < this.entities.length; i++) {\n      cb(this.entities[i])\n    }\n  },\n  forEachVisibleEntity: function(cb) {\n    var camera = this.camera\n    this.forEachEntity(function(entity) {\n      if(camera.isVisible(entity.x, entity.y, entity.width, entity.height)) cb(entity)\n    })\n  },\n  removeEntity: function(entity) {\n    entity.removeProxy(this)\n    this.entities = _.without(this.entities, entity)\n  },\n  addLayer: function(layer) {\n    this.layers.push(layer)\n  },\n  entityAt: function(worldx, worldy) {\n    for(var i = 0; i < this.entities.length; i++) {\n      var entity = this.entities[i]\n      if(entity.x > worldx) continue\n      if(entity.y > worldy) continue\n      if(entity.x + entity.width < worldx) continue\n      if(entity.y + entity.height < worldy) continue\n      return entity\n    }\n    return null\n  },\n  renderLayer: function(layer) {\n    layer.render(this.context)\n  },\n}\n_.extend(Scene.prototype, Eventable.prototype)\n\nmodule.exports = Scene\n\n\n//@ sourceURL=/node_modules/primo/lib/scene.js"
));

require.define("/node_modules/primo/node_modules/primo-camera/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"camera.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-camera/package.json"
));

require.define("/node_modules/primo/node_modules/primo-camera/camera.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Camera = function(context, settings) {\r\n  settings = settings || {}\r\n  this.distance = 1000.0\r\n  this.lookat = [0,0]\r\n  this.context = context\r\n  this.fieldOfView = settings.fieldOfView || Math.PI / 4.0\r\n  this.viewport = {\r\n    left: 0,\r\n    right: 0,\r\n    top: 0,\r\n    bottom: 0,\r\n    width: 0,\r\n    height: 0,\r\n    scale: [1.0, 1.0]\r\n  }\r\n  this.updateViewport()\r\n}\r\n\r\nCamera.prototype = {\r\n  isVisible: function(x, y, width, height) {\r\n    if(x > this.viewport.right) return false\r\n    if(y > this.viewport.bottom) return false\r\n    if(x + width < this.viewport.left) return false\r\n    if(y + height < this.viewport.top) return false\r\n    return true\r\n  },\r\n  begin: function() {\r\n    this.context.save()\r\n    this.applyScale()\r\n    this.applyTranslation()\r\n  },\r\n  end: function() {\r\n    this.context.restore()\r\n  },\r\n  applyScale: function() {\r\n    this.context.scale(this.viewport.scale[0], this.viewport.scale[1])\r\n  },\r\n  applyTranslation: function() {\r\n    this.context.translate(-this.viewport.left, -this.viewport.top)\r\n  },\r\n  updateViewport: function() {\r\n    this.aspectRatio = this.context.canvas.width / this.context.canvas.height\r\n    this.viewport.width = this.distance * Math.tan(this.fieldOfView)\r\n    this.viewport.height = this.viewport.width / this.aspectRatio\r\n    this.viewport.left = this.lookat[0] - (this.viewport.width / 2.0)\r\n    this.viewport.top = this.lookat[1] - (this.viewport.height / 2.0)\r\n    this.viewport.right = this.viewport.left + this.viewport.width\r\n    this.viewport.bottom = this.viewport.top + this.viewport.height\r\n    this.viewport.scale[0] = this.context.canvas.width / this.viewport.width\r\n    this.viewport.scale[1] = this.context.canvas.height / this.viewport.height\r\n  },\r\n  zoomTo: function(z) {\r\n    this.distance = z\r\n    this.updateViewport()\r\n  },\r\n  move: function(x, y) {\r\n    this.lookat[0] += x \r\n    this.lookat[1] += y\r\n    this.updateViewport()\r\n  },\r\n  moveTo: function(x, y) {\r\n    this.lookat[0] = x\r\n    this.lookat[1] = y\r\n    this.updateViewport()\r\n  },\r\n  canvasToWorld: function(x, y, obj) {\r\n    obj = obj || {}\r\n    x -= this.context.canvas.offsetLeft\r\n    y -= this.context.canvas.offsetTop\r\n    obj.worldx = (x / this.viewport.scale[0]) + this.viewport.left\r\n    obj.worldy = (y / this.viewport.scale[1]) + this.viewport.top\r\n    return obj\r\n  },\r\n  worldToCanvas: function(x, y, obj) {\r\n    obj = obj || {}\r\n    obj.screenx = (x - this.viewport.left) * (this.viewport.scale[0])\r\n    obj.screeny = (y - this.viewport.top) * (this.viewport.scale[1])\r\n    obj.screenx += this.context.canvas.offsetLeft\r\n    obj.screeny += this.context.canvas.offsetTop\r\n    return obj      \r\n  },\r\n  makeTopLeftWorldCoords: function(x,y) {\r\n    this.lookat[0] = x + (this.viewport.width/2.0)\r\n    this.lookat[1] = x + (this.viewport.height/2.0)\r\n    this.updateViewport()\r\n  },\r\n  setViewport: function(x, y, width, height) {\r\n    this.distance = width / Math.tan(this.fieldOfView)\r\n    this.aspectRatio = width / height\r\n    this.updateViewport()\r\n    this.makeTopLeftWorldCoords(x, y)\r\n  },\r\n  scalex: function() {\r\n    return this.viewport.scale[0]\r\n  },\r\n  scaley: function() {\r\n    return this.viewport.scale[1]\r\n  }\r\n}\r\n\r\nmodule.exports = Camera\r\n  \r\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-camera/camera.js"
));

require.define("/node_modules/primo/lib/level.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar _ = require('underscore')\nvar SpriteMap = require('primo-spritemap')\n\nvar Layer = require('./layer')\n\nvar Level = function(engine, path) {\n  Eventable.call(this)\n  this.path = path\n  this.rawdata = null\n  this.tilesets = {}\n  this.spritemaps = {}\n  this.entityTypes = {}\n  this.pendingResults = 0\n  this.finished = false\n  this.engine = engine\n  this.load()\n}\n\nLevel.prototype = {\n  width: function() {\n    return this.rawdata.width\n  },\n  height: function() {\n    return this.rawdata.height\n  },\n  tilesize: function() {\n    return this.rawdata.tilesize\n  },\n  layerdata: function(index) {\n    return this.rawdata.layers[index]\n  },\n  tileset: function(name) {\n    return this.tilesets[name]\n  },\n  spritemap: function(name) {\n    return this.spritemaps[name]\n  },\n  load: function() {\n    $.getJSON(this.path, _.bind(this.onLevelReceived, this))\n  },\n  worldToTile: function(world) {\n    return Math.floor(world / this.rawdata.tilesize)\n  },\n  checkQuadMovement: function(x, y, width, height, velx, vely, res) {\n    var steps = Math.ceil(Math.max(Math.abs(velx), Math.abs(vely)))\n    var stepx = velx / steps\n    var stepy = vely / steps\n    res = res || {}\n\n    var topleft = false, \n        topright = false, \n        bottomleft = false, \n        bottomright = false \n\n    for(var i = 0 ; i < steps ; i++) {\n      var offsetx = stepx * i\n      var offsety = stepy * i\n\n      if(this.solidAt(x + offsetx, y + offsety))\n        topleft = true\n\n      if(this.solidAt(x + offsetx + width, y + offsety))\n        topright = true\n\n      if(this.solidAt(x + offsetx, y + offsety + height))\n        bottomleft = true\n\n      if(this.solidAt(x + offsetx + width, y + offsety + height))\n        bottomright = true\n\n      if(topleft || topright || bottomleft || bottomright) {\n        res.x = x + offsetx - stepx\n        res.y = y + offsety - stepy\n\n        if(bottomleft && bottomright)\n          res.horizontal = true\n        if(topleft && topright)\n          res.horizontal = true\n        if(topright && bottomright)\n          res.vertical = true\n        if(topleft && bottomleft)\n          res.vertical = true\n\n        res.collision = true\n\n        break\n      }\n    }\n    return res\n  },\n  solidAt: function(worldx, worldy) {\n    var x = parseInt(worldx, 10)\n    var y = parseInt(worldy, 10)\n    if(x < 0) return false\n    if(y < 0) return false\n    if(x >= this.width() * this.rawdata.tilesize) return false\n    if(y >= this.height() * this.rawdata.tilesize) return false\n\n    for(var i = 0 ; i < this.layers.length; i++) {\n      var layer = this.layers[i]\n      if(layer.iscollision() && layer.solidAt(x, y)) return true\n    }\n    return false\n  },\n  layerCount: function() {\n    return this.data.layers.length\n  },\n  onLevelReceived: function(rawdata) {\n    this.rawdata = rawdata\n    this.tilesets = {}\n    this.entityTypes = {}\n    this.layers = []\n    this.loadLayers()\n    this.loadEntities()\n    this.finished = true\n    this.tryFinish()\n  },\n  loadLayers: function() {\n    for(var i = 0 ; i < this.rawdata.layers.length; i++) \n      this.loadLayer(i)\n  },\n  addLayer: function(data) {\n    var i = this.rawdata.layers.length\n    this.rawdata.layers.push(data)\n    this.layers.push(new Layer(this, i))\n    this.loadLayer(i)\n  },\n  loadLayer: function(i) {\n    var layer = this.rawdata.layers[i]\n    var tilesets = this.tilesets\n    var spritemaps = this.spritemaps\n    var collisionmaps = this.collisionmaps\n    var tilesize = this.tilesize()\n    var engine = this.engine\n\n    this.require(layer.tileset, function(tileset) {\n      tilesets[layer.tileset] = tileset\n      spritemaps[layer.tileset] = \n        engine.resources.spritemap(tileset.path, tileset.tilesize, tileset.tilesize)\n      spritemaps[layer.tileset].generateCollisionMaps(tilesize, tilesize)\n    })\n  },\n  loadEntities: function() {\n    for(var key in this.rawdata.entityTypes)  {\n      this.loadEntity(key)\n    }\n  },\n  loadEntity: function(key) {\n    var path = this.rawdata.entityTypes[key]\n    var entities = this.entityTypes\n    this.require(path, function(type) {\n      entities[key] = type\n    })\n  },\n  require: function(dep, callback) {\n    var self = this\n    this.pendingResults++\n    require([dep], function(res) {\n       callback(res)\n       self.pendingResults--\n       self.tryFinish()\n    })\n  },\n  tryFinish: function() {\n    if(this.pendingResults === 0 && this.finished) {\n      this.createLayers()\n      this.raise('loaded')\n    }\n  },\n  createLayers: function() {\n    for(var i = 0 ; i < this.rawdata.layers.length; i++) {\n      this.layers[i] = new Layer(this, i)\n    }\n  },\n  forEachLayer: function(cb) {\n    for(var i = 0 ; i < this.layers.length; i++) {\n      cb(this.layers[i])\n    }\n  },\n  loadIntoScene: function(scene) {\n    scene.reset()\n    var i = 0\n    for(i = 0; i < this.rawdata.entities.length; i++) {\n      var config = this.rawdata.entities[i]\n      var type = this.entityTypes[config.type]\n      scene.spawnEntity(type, config.data)\n    }\n  },\n  indexForWorldCoords: function(x, y) {\n    var tilex = Math.floor(x / this.rawdata.tilesize)\n    var tiley = Math.floor(y / this.rawdata.tilesize)\n    var index = tilex + tiley * this.rawdata.width\n    return index\n  },\n  setTileAt: function(layer, x, y, tile) {\n    var index = this.indexForWorldCoords(x, y)\n    this.rawdata.layers[layer].data[index] = tile\n  },\n  getTileAt: function(layer, x, y, tile) {\n    var index = this.indexForWorldCoords(x, y)\n    return this.rawdata.layers[layer].data[index] \n  }\n}\n\n_.extend(Level.prototype, Eventable.prototype)\n\nmodule.exports = Level\n\n\n//@ sourceURL=/node_modules/primo/lib/level.js"
));

require.define("/node_modules/primo/node_modules/primo-spritemap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"spritemap.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-spritemap/package.json"
));

require.define("/node_modules/primo/node_modules/primo-spritemap/spritemap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar MemoryCanvas = require('primo-canvas')\nvar Eventable = require('primo-events')\n\nvar SpriteMap = function(texture, tilecountwidth, tilecountheight) {\n  Eventable.call(this)\n  this.tilewidth = 0\n  this.tileheight = 0\n  this.tilecountwidth = tilecountwidth || 1\n  this.tilecountheight = tilecountheight || 1\n  this.tilecount = tilecountwidth * tilecountheight \n  this.collisionmapsize = 0\n  this.collisionMaps = []\n  this.texture = texture\n  this.loaded = false\n  this.texture.waitForLoaded(_.bind(this.onLoaded, this))\n}\n\nSpriteMap.prototype = {\n  drawTo: function(context, index,  x, y, width, height, flipx, flipy, rotation) {\n    if(!this.loaded) return\n\n    var img = this.texture.get()\n\n    var rownumber = Math.floor(index / this.tilecountwidth)\n    var columnnumber = index % this.tilecountwidth\n\n    var sx = columnnumber * this.tilewidth\n    var sy = rownumber * this.tileheight\n\n    var scalex = flipx ? -1 : 1\n    var scaley = flipy ? -1 : 1\n    var contextSaved = false\n\n    if(rotation) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.translate(x + width/2.0, y + height/2.0)\n      context.rotate(rotation)\n      context.translate(-(x + width/2.0),-(y + height/2.0))\n    }\n\n    if(flipx || flipy) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.scale(scalex, scaley)\n      x *= scalex\n      y *= scaley\n      if(flipx)\n        x -= width\n      if(flipy)\n        y -= height\n      contextSaved = true\n    } \n\n\n    context.drawImage(img, \n      sx, sy, this.tilewidth, this.tileheight,\n      x, y , width || this.tilewidth, height || this.tileheight)\n\n    if(contextSaved) \n      context.restore()\n  },\n  generateCollisionMaps: function(width, height) {\n    if(!this.loaded) \n      return this.once('loaded', \n        function() { \n          this.generateCollisionMaps(width, height) }, this)\n\n    // TODO: This doesn't really belong here, it needs storing elsewhere or returning\n    this.collisionmapsize = width\n    var canvas = new MemoryCanvas(width, height)\n\n    try {\n      for(var i = 0; i < this.tilecount ; i++) {\n        canvas.reset()\n        this.drawTo(canvas.context, i, 0, 0, width, height)\n        this.collisionMaps[i] = canvas.createMap()\n      }\n    }\n    catch(ex) {\n      throw ex\n    }\n    finally {\n      canvas.dispose()\n    }\n  },\n  hasPixelAt: function(index, x, y) {\n    if(!this.loaded) return false\n    var map = this.collisionMaps[index]\n    return map[x + y * this.collisionmapsize]\n  },\n  onLoaded: function() {\n    this.loaded = true\n    var img = this.texture.get()\n    this.tilewidth = img.width / this.tilecountwidth\n    this.tileheight = img.height / this.tilecountheight\n    this.raise('loaded')\n  }\n}\n_.extend(SpriteMap.prototype, Eventable.prototype)\n\nmodule.exports = SpriteMap\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-spritemap/spritemap.js"
));

require.define("/node_modules/primo/node_modules/primo-canvas/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"memorycanvas.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-canvas/package.json"
));

require.define("/node_modules/primo/node_modules/primo-canvas/memorycanvas.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var MemoryCanvas = function(width, height) {\n  this.width = width\n  this.height = height\n  this.canvas = document.createElement('canvas')\n  this.canvas.width = width \n  this.canvas.height = height \n  this.context = this.canvas.getContext('2d')\n}\nMemoryCanvas.prototype = {\n  reset: function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0)\n    this.context.clearRect(0,0, this.width, this.height)\n  },\n  setup: function(width, height) {\n    this.reset()\n\n    var scalex = this.width / width\n      , scaley = this.height / height\n\n    this.context.scale(scalex, scaley)\n  },\n  getImage: function() {\n    return this.canvas.toDataURL()\n  },\n  createMap: function() {\n    var data = this.context.getImageData(0,0, this.width, this.height).data\n    var map = new Array(this.width * this.height)\n    for(var y = 0; y < this.height; y++) {\n      for(var x = 0; x < this.width; x++) {\n        var index = x + y*this.width\n        var pixelindex = index * 4\n        var total = data[pixelindex] + data[pixelindex+1] + data[pixelindex+2]\n        if(total)\n          map[index] = 1\n        else\n          map[index] = 0\n      }\n    }\n    return map\n  },\n  dispose: function() {\n    document.removeElement(this.canvas)\n  }\n}\nmodule.exports = MemoryCanvas\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-canvas/memorycanvas.js"
));

require.define("/node_modules/primo/lib/layer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var SpriteMap = require('primo-spritemap')\n\nvar Layer = function(level, index) {\n  this.level = level\n  this.config = this.level.layerdata(index)\n  this.index = index\n  this.hidden = false\n}\nLayer.prototype = {\n  name: function() {\n    return this.config.name\n  },\n  tileset: function() {\n    return this.level.tileset(this.config.tileset)\n  },\n  setTileAt: function(x, y, tile) {\n    this.level.setTileAt(this.index, x, y, tile)\n  },\n  getTileAt: function(x, y, tile) {\n    return this.level.getTileAt(this.index, x, y, tile)\n  },\n  iscollision: function(value) {\n    if(typeof value !== 'undefined') {\n      this.config.collision = value\n    }\n    return !!this.config.collision\n  },\n  solidAt: function(x, y) {\n    var tilex = parseInt( x / this.level.tilesize(), 10)\n    var tiley = parseInt( y / this.level.tilesize(), 10)\n    var remainderx = x % this.level.tilesize()\n    var remaindery = y % this.level.tilesize()\n\n    var index = this.config.data[tilex + tiley * this.level.width()]\n    if(index === null) return false\n    return this.spritemap().hasPixelAt(index, remainderx, remaindery)\n  },\n  hide: function() {\n    this.hidden = true\n  },\n  show: function() {\n    this.hidden = false\n  },\n  spritemap: function() {\n    return this.level.spritemap(this.config.tileset)\n  },\n  render: function(context) {\n    if(this.hidden) return\n    for(var x = 0; x < this.level.width() ; x++) {\n      for(var y = 0; y < this.level.height() ; y++) {\n        var index = x + (y * this.level.width())\n        var left = x * this.level.tilesize()\n        var top = y * this.level.tilesize()\n\n        if(this.config.data[index] === null)\n          continue\n\n        this.spritemap().drawTo(context, \n          this.config.data[index], \n          left, top, this.level.tilesize(), this.level.tilesize());\n      }\n    }\n  }\n}\nmodule.exports = Layer\n\n//@ sourceURL=/node_modules/primo/lib/layer.js"
));

require.define("/node_modules/primo/lib/resources.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var SpriteMap = require('primo-spritemap')\nvar SoundResource = require('primo-audio')\nvar TextureResource = require('./textureresource')\n\nvar Resources = function() {\n  this.cache = {}\n  this.waitingForCount = 0\n}\n\nResources.prototype = {\n  spritemap: function(path, spritewidth, spriteheight) {\n    var image = this.image(path)\n    return new SpriteMap(image, spritewidth, spriteheight)\n  },\n  image: function(path) {\n    var resource = this.cache[path]\n    if(!resource) {\n      resource = new TextureResource(path)\n      this.cache[path] = resource\n      this.registerLoadingResource(resource)\n    }\n    return resource\n  },\n  sound: function(path) {\n    var resource = this.cache[path]\n    if(!resource) {\n      resource = new SoundResource(path)\n      this.cache[path] = resource\n      this.registerLoadingResource(resource)\n    }\n    return resource\n  },\n  registerLoadingResource: function(resource) {\n    this.waitingForCount++\n    resource.once('loaded', function() {\n      this.waitingForCount--\n    }, this)\n  }\n}\n\nmodule.exports = Resources\n\n\n//@ sourceURL=/node_modules/primo/lib/resources.js"
));

require.define("/node_modules/primo/node_modules/primo-audio/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"primo-audio.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/package.json"
));

require.define("/node_modules/primo/node_modules/primo-audio/primo-audio.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n  , Eventable = require('primo-events')\n\nvar Sound = function(path) {\n  Eventable.call(this)\n\n  Sound.initSystem()\n  this.path = path\n  this.loadedPath = ''\n  this.rawdata = null\n  if(!Sound.Enabled) return\n  this.detectAudio()\n}\nSound.prototype = {\n  detectAudio: function() {\n    var attempts = [ loadmp3, loadogg, loadaac, loadwav ]\n    var self = this\n    var success = function(rawdata) {\n      self.rawdata = rawdata\n      self.raise('loaded')\n    }\n    var tryNext = function() {\n      if(attempts.length === 0) {\n        console.warn('Unable to load audio for ', self.path)\n        return\n      }\n      var fn = attempts.shift()\n      fn(self.path, success, tryNext)\n    }\n    tryNext()\n  },\n  play: function() {\n    if(!Sound.Enabled) return\n    var audio = this.getAudio()\n    audio.pause()\n    audio.currentTime = 0\n    try {\n      audio.play()\n    } catch (ex) {\n      this.raise('error', ex)\n    }\n  },\n  getAudio: function() {\n    return this.rawdata\n  }\n}\n_.extend(Sound.prototype, Eventable.prototype)\n\nSound.allowBase64 = false // Shouldn't be needed if I get everthing else right\nSound.initSystem = function() {\n  if(this.initialized) return\n  var a = document.createElement('audio')\n  this.Enabled = !!a.canPlayType\n  this.mp3 = !!(a.canPlayType && a.canPlayType('audio/mpeg;').replace(/no/, ''))\n  this.ogg = !!(a.canPlayType && a.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/no/, ''))\n  this.wav = !!(a.canPlayType && a.canPlayType('audio/wav; codecs=\"1\"').replace(/no/, ''))\n  this.aac = !!(a.canPlayType && a.canPlayType('audio/mp4; codecs=\"mp4a.40.2\"').replace(/no/, ''))\n}\n\nfunction downloadFile(path, cb) {\n  var xmlHttp = new XMLHttpRequest()\n  xmlHttp.onreadystatechange = function() {\n    if(xmlHttp.readyState === 4) {\n      cb(xmlHttp.responseText)\n    }\n  }\n  xmlHttp.open( \"GET\", path, true )\n  xmlHttp.send( null )\n}\n\n\n\nfunction handleAudioLoading(audio, cb) {\n\n  var force = function () {\n    audio.pause();\n    audio.removeEventListener('play', force, false);\n    if(cb) { cb(); cb = null; }\n  };\n\n  var progress = function () {\n    audio.removeEventListener('play', force, false);\n    audio.removeEventListener('progress', progress, false);\n    if(cb) { cb(); cb = null; }\n  };\n\n  audio.addEventListener('play', force, false);\n  audio.addEventListener('progress', progress, false);\n\n  var click = document.ontouchstart === undefined ? 'click' : 'touchstart';\n  var kickoff = function () {\n    audio.play();\n    document.documentElement.removeEventListener(click, kickoff, true);\n  };\n\n  document.documentElement.addEventListener(click, kickoff, true);\n}\n\nfunction tryBase64(mime, path, success, failure) {\n  if(!Sound.allowBase64) return failure()\n  downloadFile(path, function(data) {\n    if(!data) return failure\n    var audio = new Audio()\n    audio.src = mime + ';base64,' + data\n    handleAudioLoading(audio, function() {\n      success(audio)\n    })\n  })\n}\n\nfunction tryAudio(path, success, failure) {\n  var audio = new Audio()\n  try { \n    audio.src = path\n  } catch(ex) {\n    return failure()\n  }\n  handleAudioLoading(audio, function() {\n    success(audio)\n  })\n}\n\nfunction loadmp3(path, success, failure) {\n  if(!Sound.mp3) return failure()\n  tryBase64('data:audio/mp3', path + '.mp3.base64', success, function() {\n     tryAudio(path + '.mp3', success, failure)\n   })\n}\n\nfunction loadogg(path, success, failure) {\n  if(!Sound.ogg) return false\n  tryBase64('data:audio/ogg', path + '.ogg.base64', success, function() {\n    tryAudio(path + '.ogg', success, failure)\n  })\n}\nfunction loadaac(path, success, failure) {\n  if(!Sound.aac) return false\n  tryBase64('data:audio/mp4', path + '.mp4.base64', success, function() {\n     tryAudio(path + '.mp4', success, failure)\n  })\n}\n\nfunction loadwav(path, success, failure) {\n  if(!Sound.wav) return false\n  tryBase64('data:audio/wav', path + '.wav.base64', success, function() {\n   tryAudio(path + '.wav', success, failure)\n  })\n}\n\nmodule.exports = Sound\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/primo-audio.js"
));

require.define("/node_modules/primo/lib/textureresource.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n  , Eventable = require('primo-events')\n\nvar TextureResource = function(path) {\n  Eventable.call(this)\n  this.path = path\n  this.loaded = false\n  this.image = new Image()\n  this.image.src = path\n  this.image.onload = _.bind(this.onLoaded, this)\n}\n\nTextureResource.prototype = {\n  get: function() {\n    return this.image\n  },\n  onLoaded: function() {\n    this.loaded = true\n    this.raise('loaded')\n  },\n  waitForLoaded: function(cb) {\n    if(this.loaded) cb()\n    else this.once('loaded', cb)\n  }\n}\n\n_.extend(TextureResource.prototype, Eventable.prototype)\n\nmodule.exports = TextureResource\n\n//@ sourceURL=/node_modules/primo/lib/textureresource.js"
));

require.define("/node_modules/primo/lib/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar Eventable = require('primo-events')\n\nvar Input = function(ele) {\n  Eventable.call(this)\n  document.addEventListener('keydown', _.bind(this.onKeyDown, this))\n  document.addEventListener('keyup', _.bind(this.onKeyUp, this))\n  this.aliases = {}\n  this.states = {}\n}\n\nInput.prototype = {\n  bind: function(keycode, alias) {\n    this.aliases[keycode] = alias\n  },\n  onKeyDown: function(e) {\n    var alias = this.aliases[e.keyCode]\n    if(alias) {\n      this.states[alias] = true\n    }\n    this.raise('keydown', e.keyCode)\n    return false\n  },\n  onKeyUp: function(e) {\n    var alias = this.aliases[e.keyCode]\n    if(alias) {\n      this.states[alias] = false\n    }\n    this.raise('keyup', e.keyCode)\n    return false\n  },\n  active: function(alias) {\n    return !!this.states[alias]\n  },\n  LEFT_ARROW: 37,\n  UP_ARROW: 38,\n  RIGHT_ARROW: 39,\n  DOWN_ARROW: 40,\n  LEFT_CTRL: 17,\n  RETURN: 13\n}\n\n_.extend(Input.prototype, Eventable.prototype)\n\nmodule.exports = Input\n\n\n//@ sourceURL=/node_modules/primo/lib/input.js"
));

require.define("/node_modules/primo-physics/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"physics.js\"}\n//@ sourceURL=/node_modules/primo-physics/package.json"
));

require.define("/node_modules/primo-physics/physics.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var CollisionGrid = require('./collisiongrid')\nvar RigidBody = require('./rigidbody')\n\nvar physics = {\n  init: function(game) {\n    game.on('PostTick', function() {\n      var grid = null\n      grid = new CollisionGrid(game.cellsize)\n      game.scene.forEachEntity(function(entity) {\n        if(entity.physics)\n          grid.addEntity(entity)\n      })\n      grid.performCollisionChecks()\n    })\n  },\n  RigidBody: RigidBody\n}\n\nmodule.exports = physics\n\n//@ sourceURL=/node_modules/primo-physics/physics.js"
));

require.define("/node_modules/primo-physics/collisiongrid.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar collision = require('./collision')\n\n// This is all hideous, creating lots of objects per frame, horrible dictionary usage\n// etc, will re-write it when I have time or it causes problems\n\nvar Bucket = function(id) {\n  this.id = id\n  this.entities = []\n}\n\n\nBucket.prototype = {\n  add: function(entity) {\n    this.entities.push(entity)\n  },\n  count: function() {\n    return this.entities.length\n  },\n  get: function(i) {\n    return this.entities[i]\n  }\n}\n\nvar RegisteredEntity = function(entity) {\n  this.id = entity.id\n  this.entity = entity\n  this.history = {}\n  this.buckets = []\n}\n\nRegisteredEntity.prototype = {\n  addBucket: function(bucket) {\n    this.buckets.push(bucket)\n  },\n  fillArrayWithNearbyEntities: function(array) {\n    var added = {}\n    for(var i = 0 ; i < this.buckets.length; i++) {\n      var bucket = this.buckets[i]\n      for(var j = 0; j < bucket.count(); j++) {\n        var entity = bucket.get(j)\n        if(added[entity.id]) continue\n        if(entity.id === this.id) continue\n        if(entity.history[this.id]) continue\n        added[entity.id] = true\n        array.push(entity)\n        this.history[entity.id] = true\n      }\n    }\n  },\n  collideWith: function(other) {\n    collision(this.entity, other.entity)\n  }\n}\n\nvar CollisionGrid = function(cellsize) {\n  this.cellsize = cellsize\n  this.entities = []\n  this.entityBuckets = {}\n  this.buckets = []\n}\n\nCollisionGrid.prototype = {\n  addEntity: function(entity) {\n    var registered = new RegisteredEntity(entity)\n\n    for(var x = entity.x ; x <= entity.x + entity.width + this.cellsize ; x += this.cellsize) {\n      for(var y = entity.y ; y <= entity.y + entity.height + this.cellsize ; y += this.cellsize) {\n        this.addToBucket(registered, x, y)\n      }\n    }\n\n    this.entities.push(registered)\n  },\n  addToBucket: function(entity, x, y) {\n    var bucket = this.bucketFor(x,y)\n    if(!bucket) {\n      return\n    }\n    bucket.add(entity)\n    entity.addBucket(bucket)\n  },\n  bucketFor: function(x,y) {\n    x = Math.floor(x / this.cellsize)\n    y = Math.floor(y / this.cellsize)\n    var id = x + '-' + y\n    var bucket = this.buckets[id] \n    if(!bucket) {\n      bucket = new Bucket(id)\n      this.buckets[id] = bucket\n    }\n    return bucket\n  },\n  performCollisionChecks: function() {\n    var total = 0\n    var entitiesToCheck = []\n    for(var i = 0; i < this.entities.length; i++) {\n      entitiesToCheck.length = 0\n      var registered = this.entities[i]\n      registered.fillArrayWithNearbyEntities(entitiesToCheck)\n      total += entitiesToCheck.length\n      for(var j = 0; j < entitiesToCheck.length; j++) {\n        var other = entitiesToCheck[j]\n        registered.collideWith(other)\n      }\n    }\n  }\n}\n\nmodule.exports = CollisionGrid\n\n\n//@ sourceURL=/node_modules/primo-physics/collisiongrid.js"
));

require.define("/node_modules/primo-physics/collision.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var RigidBody = require('./rigidbody')\nvar intersection = {}\n\nmodule.exports = function(one, two) {\n  var bodyOne = one.physics\n    , bodyTwo = two.physics\n\n  if(!bodyOne || !bodyTwo) return\n  if(!intersects(one, two, intersection)) return\n  if(bodyOne.group === bodyTwo.group && bodyOne.group !== 'none') return\n  if(bodyOne.dead || bodyTwo.dead) return\n  if(intersection.x === 0 && intersection.y === 0) return\n\n  one.raise('collided', two)\n  two.raise('collided', one)\n\n  if(!bodyOne.solid || !bodyTwo.solid) return\n\n  handleVerifiedCollision(one, two)\n}\n\n\nfunction intersects(one, two, intersection) {\n  var bodyOne = one.physics\n    , bodyTwo = two.physics\n\n  if(bodyOne.type === RigidBody.TYPES.BOX && bodyTwo.type === bodyOne.type) \n    return boxIntersectsWithBox(one, two, intersection)\n  else if(bodyOne.type === RigidBody.TYPES.CIRCLE && bodyTwo.type === bodyOne.type) \n    return circleIntersectsWithCircle(one, two, intersection)\n  else if(bodyOne.type === RigidBody.TYPES.CIRCLE) \n    return boxIntersectsWithCircle(one, two, intersection)\n  else \n    return boxIntersectsWithCircle(one, two, intersection)\n}\n\nfunction handleVerifiedCollision(entityOne, entityTwo) {\n  var bodyOne = entityOne.physics\n    , bodyTwo = entityTwo.physics\n\n    var entityOnePercentage = 0\n    var entityTwoPercentage = 0\n\n    if(bodyOne.weight > bodyTwo.weight) {\n      entityOnePercentage = bodyTwo.weight / (bodyTwo.weight + bodyOne.weight)\n      entityTwoPercentage = 1.0 - entityOnePercentage\n    }\n    else if(bodyOne.weight < bodyTwo.weight) {\n      entityTwoPercentage = bodyOne.weight / (bodyTwo.weight + bodyOne.weight)\n      entityOnePercentage = 1.0 - entityTwoPercentage\n    }\n    else {\n      entityOnePercentage = 0.5\n      entityTwoPercentage = 0.5\n    }\n\n    entityOne.x += intersection.x * (entityOnePercentage + 0.01)\n    entityOne.y += intersection.y * (entityOnePercentage + 0.01)\n    entityTwo.x -= intersection.x * (entityTwoPercentage + 0.01)\n    entityTwo.y -= intersection.y * (entityTwoPercentage + 0.01)\n\n    if(intersection.x < 0)\n      applyHorizontalBounce(entityOne, entityTwo, entityOnePercentage, entityTwoPercentage)\n    else if(intersection.x > 0)\n      applyHorizontalBounce(entityTwo, entityOne, entityTwoPercentage, entityOnePercentage)\n\n    if(intersection.y < 0)\n      applyVerticalBounce(entityOne, entityTwo, entityOnePercentage, entityTwoPercentage)\n    else if(intersection.y > 0)\n      applyVerticalBounce(entityTwo, entityOne, entityTwoPercentage, entityOnePercentage)\n}\n\nfunction applyHorizontalBounce(leftEntity, rightEntity, leftPercentage, rightPercentage) {\n  var leftBody = leftEntity.physics \n    , rightBody = rightEntity.physics\n\n  var bounce = (leftEntity.velx - rightEntity.velx) \n  var addition = (leftEntity.velx * rightPercentage + rightEntity.velx * leftPercentage)\n\n  leftEntity.velx = (addition *  (1.0 - leftBody.bounce)) - bounce * leftBody.bounce \n  rightEntity.velx =  (addition * (1.0 - rightBody.bounce)) + bounce * rightBody.bounce\n}\n\nfunction applyVerticalBounce(topEntity, bottomEntity, topPercentage, bottomPercentage) {\n  var topBody = topEntity.physics,\n      bottomBody = bottomEntity.physics\n  \n  var bounce = (topEntity.vely - bottomEntity.vely)\n  var addition = (topEntity.vely * bottomPercentage + bottomEntity.vely * topPercentage)\n\n  topEntity.vely = (addition * (1.0 - topBody.bounce)) - bounce  * topBody.bounce\n  bottomEntity.vely = (addition * (1.0 - bottomBody.bounce)) + bounce * bottomBody.bounce\n}\n\nfunction boxIntersectsWithBox(boxOne, boxTwo, intersection) {\n  if(boxOne.x > boxTwo.x + boxTwo.width) return\n  if(boxOne.y > boxTwo.y + boxTwo.height) return\n  if(boxOne.x + boxOne.width < boxTwo.x) return\n  if(boxOne.y + boxOne.height < boxTwo.y) return\n  calculateBoxBoxIntersection(boxOne, boxTwo, intersection)\n  return true\n}\n\nfunction boxIntersectsWithCircle(box, circle, intersection) {\n  return boxIntersectsWithBox(box, circle, intersection) // for now/ lazy\n}\n\nfunction circleIntersectsWithCircle(circleOne, circleTwo, intersection) {\n  var r1 = (circleOne.width > circleOne.height ? circleOne.width : circleOne.height) / 2.0\n    , r2 = (circleTwo.width > circleTwo.height ? circleTwo.width : circleTwo.height) / 2.0\n    , distancex = (circleOne.x + circleOne.width/2) - (circleTwo.x + circleTwo.width/2)\n    , distancey = (circleOne.y + circleOne.height/2) - (circleTwo.y + circleTwo.height/2)\n    , distance = Math.sqrt((distancex*distancex) + (distancey*distancey))\n    , overlap = (r1 + r2) - distance\n\n  if(overlap < 0) return false\n\n  // This is an aproximation making the assumption that the vector found here\n  // would be similar to the actual vector at the point of collision\n  var vx = circleOne.lastx - circleTwo.lastx\n    , vy = circleOne.lasty - circleTwo.lasty\n    , mag = Math.sqrt((vx*vx) + (vy*vy))\n\n  vx /= mag\n  vy /= mag\n\n  // Now we just need the magnitude of this vector\n  intersection.x = vx * overlap\n  intersection.y = vy * overlap\n  return true\n}\n\n\nfunction calculateBoxBoxIntersection(one, two, intersection) {\n  var x = 0, y = 0\n\n  // Did the right of 'one' brush into the left of 'two'?\n  if(one.lastx + one.width < two.lastx && one.x + one.width > two.x) \n    x = two.x - (one.x + one.width) \n\n  // Did the left of 'one' brush into the right of 'two'?\n  else if(one.lastx > two.lastx + two.width && one.x < two.x + two.width)\n    x = (two.x + two.width) - one.x\n\n  // Did the bottom of 'one' brush into the 'top' of 'two'?\n  if(one.lasty + one.height < two.lasty && one.y + one.height > two.y)\n    y = two.y - (one.y + one.height) \n\n  // Did the top of 'one' brush into the 'bottom' of 'two'?\n  else if(one.lasty > two.lasty + two.height && one.y < two.y + two.height)\n    y = (two.y + two.height) - one.y\n\n  // Woah, noes, mostly likely a spawn failure\n  if(x === 0 && y === 0) {\n    x = two.x - (one.x + one.width) \n    y = two.y - (one.y + one.height) \n  }\n\n  intersection.x = x\n  intersection.y = y\n}\n\n//@ sourceURL=/node_modules/primo-physics/collision.js"
));

require.define("/node_modules/primo-physics/rigidbody.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\n\nvar RigidBody = function(entity, options) {\n  options = options || {}\n  this.entity = entity\n  this.entity.physics = this\n  this.group = util.valueOrDefault(options.group, 'none')\n  this.weight = util.valueOrDefault(options.weight, 10)\n  this.gravity = util.valueOrDefault(options.gravity, 0.0)\n  this.bounce = util.valueOrDefault(options.bounce, 0.5) \n  this.type = util.valueOrDefault(options.type, RigidBody.TYPES.BOX)\n  this.solid = util.valueOrDefault(options.solid, true)\n  this.dead = false\n  this.entity.on('killed', this.onKilled, this)\n}\n\nRigidBody.TYPES =  {\n  BOX: \"box\",\n  CIRCLE: \"circle\"\n}\n\nRigidBody.prototype = {\n  onKilled: function() {\n    this.dead = true\n  }\n}\n\nmodule.exports = RigidBody\n\n\n//@ sourceURL=/node_modules/primo-physics/rigidbody.js"
));

require.define("/node_modules/primo-menu/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"primo-menu.js\"}\n//@ sourceURL=/node_modules/primo-menu/package.json"
));

require.define("/node_modules/primo-menu/primo-menu.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Menu = require('./menu')\n\nmodule.exports = {\n  init: function(engine) {\n    if(!engine.ui) throw new Error(\"primo-ui is not loaded, this is required for primo-menu to work\")\n    engine.menu = new Menu(engine)\n  }\n}\n\n//@ sourceURL=/node_modules/primo-menu/primo-menu.js"
));

require.define("/node_modules/primo-menu/menu.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar ui = require('primo-ui')\n\nvar Menu = function(engine) {\n  this.engine = engine\n  this.items = []\n  this.options = []\n  this.selectedIndex = 0\n  this.selectionToken = new ui.Rect({ x: 0, y: 0, width: 10, height: 10, colour: '#F00'})\n  this.onKeyDown = _.bind(this.onKeyDown, this)\n}\n\nMenu.prototype = {\n  addOption: function(option, action) {\n    this.items.push(option)\n    this.options.push(option)\n    this.engine.ui.add(option)\n    option.action = action\n    if(this.options.length === 1) this.selectIndex(0)\n    return this\n  },\n  addDisplay: function(display) {\n    this.items.push(display)\n    this.engine.ui.add(display)\n    return this\n  },\n  show: function() {\n    this.clear()\n    this.engine.input.on('keydown', this.onKeyDown)\n    this.selectedIndex = 0\n    this.engine.ui.add(this.selectionToken)\n    return this\n  },\n  hide: function() {\n    this.clear()\n    return this\n  },\n  clear: function() {\n    this.engine.input.off('keydown', this.onKeyDown)\n    for(var i = 0 ; i < this.items.length; i++)\n      this.engine.ui.remove(this.items[i])\n    this.items.length = 0\n    this.options.length = 0\n    this.engine.ui.remove(this.selectionToken)\n    return this\n  },\n  onKeyDown: function(key) {\n    if(key === this.engine.input.UP_ARROW)\n      this.decreaseIndex()\n    else if(key === this.engine.input.DOWN_ARROW)\n      this.increaseIndex()\n    else if(key === this.engine.input.RETURN)\n      this.executeCurrentOption()\n  },\n  increaseIndex: function() {\n    var index = this.selectedIndex+1\n    if(index >= this.options.length)\n      index = this.options.length-1\n    this.selectIndex(index)\n  },\n  decreaseIndex: function() {\n    var index = this.selectedIndex - 1\n    if(index < 0) index = 0\n    this.selectIndex(index)\n  },\n  selectIndex: function(index) {\n    this.selectedIndex = index\n    var option = this.options[this.selectedIndex]\n    this.selectionToken.x = option.x - (option.height/2) - 10\n    this.selectionToken.y = option.y + (option.height/2)\n    this.selectionToken.width = option.height/2\n    this.selectionToken.height = option.height/2\n  },\n  executeCurrentOption: function() {\n    var option = this.options[this.selectedIndex]\n    option.action()\n  }\n}\n\n\nmodule.exports = Menu\n\n//@ sourceURL=/node_modules/primo-menu/menu.js"
));

require.define("/node_modules/primo-menu/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo-menu/node_modules/underscore/package.json"
));

require.define("/node_modules/primo-menu/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/package.json"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var PrimoUi = require('./container')\nvar Rect = require('./rect')\nvar Label = require('./label')\n\nmodule.exports = {\n  init: function(game, options) {\n    game.ui = new PrimoUi(game, options)\n  },\n  Rect: Rect,\n  Label: Label\n}\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/index.js"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/container.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\nvar _ = require('underscore')\n\nvar PrimoUi = function(game, cfg) {\n  this.game = game\n  this.width = util.valueOrDefault(cfg.width, 100)\n  this.height = util.valueOrDefault(cfg.height, 100)\n  this.items = []\n}\n\nPrimoUi.prototype = {\n  show: function() {\n    this.game.on('render', this.render, this)\n    this.game.on('tick', this.tick, this)\n  },\n  hide: function() {\n    this.game.off('render', this.render, this)\n    this.game.off('tick', this.tick, this)\n  },\n  clear: function() {\n    this.items.length = 0\n  },\n  add: function(element) {\n    this.items.push(element)\n    return element\n  },\n  remove: function(element) {\n    this.items = _.without(this.items, element)\n  },\n  tick: function(frameTime) {\n    _.each(this.items, function(item) { if(item.tick) item.tick(frameTime) })\n  },\n  render: function(context) {\n    context.save()\n    context.setTransform(1,0,0,1,0,0)\n    context.scale(context.canvas.width / this.width, context.canvas.height / this.height)\n    _.each(this.items, function(item) { item.render(context) })\n    context.restore()\n  }\n}\n\nmodule.exports = PrimoUi\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/container.js"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/node_modules/primo-utils/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"commons.js\"}\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/node_modules/primo-utils/package.json"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/node_modules/primo-utils/commons.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\n  valueOrDefault: function(value, def) {\n    return typeof value !== 'undefined' ? \n         value : \n         def\n  }\n}\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/node_modules/primo-utils/commons.js"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/rect.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Rect = function(data) {\n  this.x = data.x\n  this.y = data.y\n  this.width = data.width\n  this.height = data.height\n  this.colour = data.colour\n}\n\nRect.prototype = {\n  render: function(context) {\n    context.fillStyle = this.colour\n    context.fillRect(this.x, this.y, this.width, this.height)\n  }\n}\n\nmodule.exports = Rect\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/rect.js"
));

require.define("/node_modules/primo-menu/node_modules/primo-ui/label.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\n\nvar Label = function(data) {\n  this.x = data.x\n  this.y = data.y\n  this.height = data.height\n  this.font = util.valueOrDefault(data.font, 'sans-serif')\n  this.colour = util.valueOrDefault(data.colour, '#F00')\n  this.text = util.valueOrDefault(data.text, \"\") \n}\n\nLabel.prototype = {\n  render: function(context) {\n    context.fillStyle = this.colour\n    context.font = this.height + 'px ' + this.font\n    context.fillText(this.text, this.x, this.y + this.height)\n  }\n}\n\nmodule.exports = Label\n\n//@ sourceURL=/node_modules/primo-menu/node_modules/primo-ui/label.js"
));

require.define("/node_modules/primo-ui/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/primo-ui/package.json"
));

require.define("/node_modules/primo-ui/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var PrimoUi = require('./container')\nvar Rect = require('./rect')\nvar Label = require('./label')\n\nmodule.exports = {\n  init: function(game, options) {\n    game.ui = new PrimoUi(game, options)\n  },\n  Rect: Rect,\n  Label: Label\n}\n\n//@ sourceURL=/node_modules/primo-ui/index.js"
));

require.define("/node_modules/primo-ui/container.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\nvar _ = require('underscore')\n\nvar PrimoUi = function(game, cfg) {\n  this.game = game\n  this.width = util.valueOrDefault(cfg.width, 100)\n  this.height = util.valueOrDefault(cfg.height, 100)\n  this.items = []\n  this.show()\n}\n\nPrimoUi.prototype = {\n  show: function() {\n    this.game.on('render', this.render, this)\n    this.game.on('tick', this.tick, this)\n  },\n  hide: function() {\n    this.game.off('render', this.render, this)\n    this.game.off('tick', this.tick, this)\n  },\n  clear: function() {\n    this.items.length = 0\n  },\n  add: function(element) {\n    this.items.push(element)\n    return element\n  },\n  remove: function(element) {\n    this.items = _.without(this.items, element)\n  },\n  tick: function(frameTime) {\n    _.each(this.items, function(item) { if(item.tick) item.tick(frameTime) })\n  },\n  render: function(context) {\n    context.save()\n    context.setTransform(1,0,0,1,0,0)\n    context.scale(context.canvas.width / this.width, context.canvas.height / this.height)\n    _.each(this.items, function(item) { item.render(context) })\n    context.restore()\n  }\n}\n\nmodule.exports = PrimoUi\n\n//@ sourceURL=/node_modules/primo-ui/container.js"
));

require.define("/node_modules/primo-ui/node_modules/primo-utils/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"commons.js\"}\n//@ sourceURL=/node_modules/primo-ui/node_modules/primo-utils/package.json"
));

require.define("/node_modules/primo-ui/node_modules/primo-utils/commons.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\n  valueOrDefault: function(value, def) {\n    return typeof value !== 'undefined' ? \n         value : \n         def\n  }\n}\n\n//@ sourceURL=/node_modules/primo-ui/node_modules/primo-utils/commons.js"
));

require.define("/node_modules/primo-ui/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo-ui/node_modules/underscore/package.json"
));

require.define("/node_modules/primo-ui/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo-ui/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo-ui/rect.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Rect = function(data) {\n  this.x = data.x\n  this.y = data.y\n  this.width = data.width\n  this.height = data.height\n  this.colour = data.colour\n  this.hidden = false\n}\n\nRect.prototype = {\n  render: function(context) {\n    if(this.hidden) return\n    context.fillStyle = this.colour\n    context.fillRect(this.x, this.y, this.width, this.height)\n  },\n  hide: function() {\n    this.hidden = true\n  },\n  show: function() {\n    this.hidden = false\n  }\n}\n\nmodule.exports = Rect\n\n//@ sourceURL=/node_modules/primo-ui/rect.js"
));

require.define("/node_modules/primo-ui/label.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\n\nvar Label = function(data) {\n  this.x = data.x\n  this.y = data.y\n  this.height = data.height\n  this.font = util.valueOrDefault(data.font, 'sans-serif')\n  this.colour = util.valueOrDefault(data.colour, '#F00')\n  this.text = util.valueOrDefault(data.text, \"\") \n  this.align = util.valueOrDefault(data.align, \"left\")\n  this.hidden = false\n}\n\nLabel.prototype = {\n  render: function(context) {\n    if(this.hidden) return\n    context.fillStyle = this.colour\n    context.textAlign = this.align\n    context.font = this.height + 'px ' + this.font\n    context.fillText(this.text, this.x, this.y + this.height)\n  },\n  hide: function() {\n    this.hidden = true\n  },\n  show: function() {\n    this.hidden = false\n  }\n}\n\nmodule.exports = Label\n\n//@ sourceURL=/node_modules/primo-ui/label.js"
));

require.define("/site/entities/planet.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar Animation = require('primo-animation')\nvar Health = require('../future/primo-health')\nvar RigidBody = require('primo-physics').RigidBody\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.id = 'planet'\n  this.x = data.x - data.radius\n  this.y = data.y - data.radius\n  this.width = data.radius * 2.0\n  this.height = data.radius * 2.0\n  this.attach(new Animation(this, \"media/largeplanet.png\"))\n  this.attach(new Health(this))\n  this.attach(new RigidBody(this, {\n    weight: Infinity,\n    gravity: 0,\n    bounce: 0,\n    type: \"circle\"\n  }))\n  this.on('killed', function() {\n    this.raise('player-died')\n  })\n})\n\n//@ sourceURL=/site/entities/planet.js"
));

require.define("/node_modules/primo-animation/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"animation.js\"}\n//@ sourceURL=/node_modules/primo-animation/package.json"
));

require.define("/node_modules/primo-animation/animation.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar SpriteMap = require('primo-spritemap')\n\nvar Animation = function(entity, path, tilecountwidth, tilecountheight) {\n  this.entity = entity\n  this.path = path\n  this.spritemap = entity.game.resources.spritemap(path, tilecountwidth, tilecountheight)\n  this.currentanimation = 'idle'\n  this.current = 0\n  this.totalFrameTime = 0\n  this.animations = {}\n  this.entity.handle('set-animation', _.bind(this.setAnimation, this))\n  this.define('idle', 1.0, [0])\n}\n\nAnimation.prototype = {\n  tick: function(frameTime) {\n    var anim = this.animations[this.currentanimation]\n    if(!anim) return\n    this.totalFrameTime += frameTime\n    if(this.totalFrameTime >= anim.timePerFrame) {\n      if(++this.current === anim.steps.length)\n        this.current = 0\n      this.totalFrameTime = 0\n    }\n  },\n  render: function(context) {\n    var anim = this.animations[this.currentanimation]\n    if(!anim) return\n    var entity = this.entity\n    this.spritemap.drawTo(context, anim.steps[this.current], \n      entity.x, entity.y, entity.width, entity.height, \n      anim.options.flipx, anim.options.flipy, entity.rotation)\n  },\n  define: function(name, timePerFrame, steps, options) {\n    this.animations[name] = {\n      timePerFrame: timePerFrame,\n      steps: steps,\n      options: options || {},\n      current: 0\n    }\n    return this\n  },\n  setAnimation: function(animation) {\n    if(this.currentanimation === animation) return\n    this.currentanimation = animation\n    this.current = 0\n  }\n}\n\nmodule.exports = Animation\n\n//@ sourceURL=/node_modules/primo-animation/animation.js"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"spritemap.js\"}\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/package.json"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/spritemap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar MemoryCanvas = require('primo-canvas')\nvar Eventable = require('primo-events')\n\nvar SpriteMap = function(texture, tilecountwidth, tilecountheight) {\n  Eventable.call(this)\n  this.tilewidth = 0\n  this.tileheight = 0\n  this.tilecountwidth = tilecountwidth || 1\n  this.tilecountheight = tilecountheight || 1\n  this.tilecount = tilecountwidth * tilecountheight \n  this.collisionmapsize = 0\n  this.collisionMaps = []\n  this.texture = texture\n  this.loaded = false\n  this.texture.waitForLoaded(_.bind(this.onLoaded, this))\n}\n\nSpriteMap.prototype = {\n  drawTo: function(context, index,  x, y, width, height, flipx, flipy, rotation) {\n    if(!this.loaded) return\n\n    var img = this.texture.get()\n\n    var rownumber = Math.floor(index / this.tilecountwidth)\n    var columnnumber = index % this.tilecountwidth\n\n    var sx = columnnumber * this.tilewidth\n    var sy = rownumber * this.tileheight\n\n    var scalex = flipx ? -1 : 1\n    var scaley = flipy ? -1 : 1\n    var contextSaved = false\n\n    if(rotation) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.translate(x + width/2.0, y + height/2.0)\n      context.rotate(rotation)\n      context.translate(-(x + width/2.0),-(y + height/2.0))\n    }\n\n    if(flipx || flipy) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.scale(scalex, scaley)\n      x *= scalex\n      y *= scaley\n      if(flipx)\n        x -= width\n      if(flipy)\n        y -= height\n      contextSaved = true\n    } \n\n\n    context.drawImage(img, \n      sx, sy, this.tilewidth, this.tileheight,\n      x, y , width || this.tilewidth, height || this.tileheight)\n\n    if(contextSaved) \n      context.restore()\n  },\n  generateCollisionMaps: function(width, height) {\n    if(!this.loaded) \n      return this.once('loaded', \n        function() { \n          this.generateCollisionMaps(width, height) }, this)\n\n    // TODO: This doesn't really belong here, it needs storing elsewhere or returning\n    this.collisionmapsize = width\n    var canvas = new MemoryCanvas(width, height)\n\n    try {\n      for(var i = 0; i < this.tilecount ; i++) {\n        canvas.reset()\n        this.drawTo(canvas.context, i, 0, 0, width, height)\n        this.collisionMaps[i] = canvas.createMap()\n      }\n    }\n    catch(ex) {\n      throw ex\n    }\n    finally {\n      canvas.dispose()\n    }\n  },\n  hasPixelAt: function(index, x, y) {\n    if(!this.loaded) return false\n    var map = this.collisionMaps[index]\n    return map[x + y * this.collisionmapsize]\n  },\n  onLoaded: function() {\n    this.loaded = true\n    var img = this.texture.get()\n    this.tilewidth = img.width / this.tilecountwidth\n    this.tileheight = img.height / this.tilecountheight\n    this.raise('loaded')\n  }\n}\n_.extend(SpriteMap.prototype, Eventable.prototype)\n\nmodule.exports = SpriteMap\n\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/spritemap.js"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-canvas/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"memorycanvas.js\"}\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-canvas/package.json"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-canvas/memorycanvas.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var MemoryCanvas = function(width, height) {\n  this.width = width\n  this.height = height\n  this.canvas = document.createElement('canvas')\n  this.canvas.width = width \n  this.canvas.height = height \n  this.context = this.canvas.getContext('2d')\n}\nMemoryCanvas.prototype = {\n  reset: function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0)\n    this.context.clearRect(0,0, this.width, this.height)\n  },\n  setup: function(width, height) {\n    this.reset()\n\n    var scalex = this.width / width\n      , scaley = this.height / height\n\n    this.context.scale(scalex, scaley)\n  },\n  getImage: function() {\n    return this.canvas.toDataURL()\n  },\n  createMap: function() {\n    var data = this.context.getImageData(0,0, this.width, this.height).data\n    var map = new Array(this.width * this.height)\n    for(var y = 0; y < this.height; y++) {\n      for(var x = 0; x < this.width; x++) {\n        var index = x + y*this.width\n        var pixelindex = index * 4\n        var total = data[pixelindex] + data[pixelindex+1] + data[pixelindex+2]\n        if(total)\n          map[index] = 1\n        else\n          map[index] = 0\n      }\n    }\n    return map\n  },\n  dispose: function() {\n    document.removeElement(this.canvas)\n  }\n}\nmodule.exports = MemoryCanvas\n\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-canvas/memorycanvas.js"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo-animation/node_modules/primo-spritemap/node_modules/primo-events/eventcontainer.js"
));

require.define("/site/future/primo-health.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\nvar _ = require('underscore')\n\nvar Health = function(entity, data) {\n  this.max = 100\n  this.amount = 100\n  this.entity = entity\n  this.entity.health = this\n  this.entity.handle('damage', _.bind(this.damage, this))\n}\n\nHealth.prototype = {\n  damage: function(amount) {\n    this.amount -= amount\n    this.entity.raise('damaged', this.amount)\n    this.entity.raise('health-changed', this.amount)\n    if(this.amount <= 0)\n      this.entity.kill()\n  },\n  increase: function(amount) {\n    this.amount += amount\n    if(this.amount > this.max)\n      this.amount = this.max\n    this.entity.raise('regenned', this.amount)\n    this.entity.raise('health-changed', this.amount)\n  }\n\n}\n\nmodule.exports = Health\n\n//@ sourceURL=/site/future/primo-health.js"
));

require.define("/site/entities/defender.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar Animation = require('primo-animation')\nvar RigidBody = require('primo-physics').RigidBody\n\nvar RotateAroundPoint = require('../components/rotatearoundpoint')\nvar FiringControl = require('../components/firingcontrol')\nvar _ = require('underscore')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.id = 'defender'\n  this.width = 20\n  this.height = 10\n  this.attach(new RigidBody(this, { solid: false }))\n  this.attach(new Animation(this, 'media/ship.png'))\n  this.attach(new RotateAroundPoint(this, data.centrex, data.centrey, data.radius))\n  this.attach(new FiringControl(this))\n})\n\n//@ sourceURL=/site/entities/defender.js"
));

require.define("/site/components/rotatearoundpoint.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var RotateAroundPoint = function(entity, x, y, radius) {\n  this.entity = entity\n  this.game = entity.game\n  this.x = x\n  this.y = y\n  this.radius = radius\n  this.angle = -Math.PI/2 \n  this.updateEntity()\n}\n\nRotateAroundPoint.prototype = {\n  tick: function() {\n    if(this.game.input.active('left'))\n      this.rotate(-0.05)\n    else if (this.game.input.active('right'))\n      this.rotate(0.05)\n\n  },\n  updateEntity: function() {\n    var x = this.x + (this.radius) * Math.cos(this.angle)\n    var y = this.y + (this.radius) * Math.sin(this.angle)\n    this.entity.x = x\n    this.entity.y = y\n    this.entity.rotation = this.angle\n  },\n  rotate: function(amount) {\n    this.angle += amount\n    this.updateEntity()\n  }\n}\nmodule.exports = RotateAroundPoint\n\n//@ sourceURL=/site/components/rotatearoundpoint.js"
));

require.define("/site/components/gradientcircle.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var GradientCircle = function(entity, inner, middle, outer) {\n  this.entity = entity\n  this.inner = inner\n  this.middle = middle\n  this.outer = outer\n}\n\nGradientCircle.prototype = {\n  render: function(context) {\n      context.beginPath();\n      var gradient = context.createRadialGradient(this.entity.x, this.entity.y, 0, \n                                                  this.entity.x, this.entity.y, this.entity.width);\n      gradient.addColorStop(0, this.inner);\n      gradient.addColorStop(0.4, this.inner);\n      gradient.addColorStop(0.4, this.middle);\n      gradient.addColorStop(1, this.outer);\n      context.fillStyle = gradient;\n      context.arc(this.entity.x, this.entity.y, this.entity.width, Math.PI * 2, false);\n      context.fill();\n  }\n}\n\nmodule.exports = GradientCircle\n\n//@ sourceURL=/site/components/gradientcircle.js"
));

require.define("/site/entities/asteroidspawner.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar Asteroid = require('./asteroid')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var spawner = this\n    , game = spawner.game\n    , variables = game.variables\n    , scene = game.scene\n\n  function spawnNextAsteroid() {\n      var angle = Math.random() * (Math.PI * 2);\n      var xdir = Math.cos(angle);\n      var ydir = Math.sin(angle);\n      var x = 1500 * xdir;\n      var y = 1500 * ydir;\n\n      var speed = 30.0 + Math.random() * variables.speedSeed;\n      var accuracy = 0.5 - Math.random()\n      var xvel = speed * ((-xdir) + accuracy);\n      var yvel = speed * ((-ydir) - accuracy);\n\n      scene.spawnEntity(Asteroid, {\n        x: x,\n        y: y,\n        velx: xvel,\n        vely: yvel\n      })\n      game.scheduleEvent(spawnNextAsteroid, variables.spawnTime)\n  }\n  spawnNextAsteroid()\n})\n\n//@ sourceURL=/site/entities/asteroidspawner.js"
));

require.define("/site/entities/explosionlistener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n\nvar Asteroid = require('./asteroid')\nvar Explosion = require('./explosion')\nvar Planet = require('./planet')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.scene.on('killed', function(data, sender) {\n    if(sender instanceof Asteroid)\n      spawnExplosionFor(sender)\n    if(sender instanceof Planet)\n      spawnGameOverExplosion(sender)\n  })\n})\n\nfunction spawnExplosionFor(asteroid) {\n  asteroid.scene.spawnEntity(Explosion, {\n    x: asteroid.x + asteroid.width/2,\n    y: asteroid.y + asteroid.height/2,\n    r: 1.0,\n    g: 0.5,\n    b: 0.01,\n    lifetime: 120       \n  })\n}\n\nfunction spawnGameOverExplosion(planet) {\n  planet.scene.spawnEntity(Explosion, {\n    x: planet.x + planet.width/2,\n    y: planet.y + planet.height/2,\n    r: 0.01,\n    g: 1.0,\n    b: 1.0,\n    lifetime: 120       \n  })\n}\n\n//@ sourceURL=/site/entities/explosionlistener.js"
));

require.define("/site/entities/explosion.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n\nvar ParticleEmitter = require('../components/particleemitter')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.attach(new ParticleEmitter(this, data))\n})\n\n//@ sourceURL=/site/entities/explosion.js"
));

require.define("/site/components/particleemitter.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var util = require('primo-utils')\n\nvar ParticleEmitter = function(entity, data) {\n  this.entity = entity\n  this.particles = [];\n  this.r = util.valueOrDefault(data.r, 1.0)\n  this.g = util.valueOrDefault(data.g, 1.0)\n  this.b = util.valueOrDefault(data.b, 1.0)\n  this.amount = util.valueOrDefault(data.amount, 10)\n  this.lifetime = util.valueOrDefault(data.lifetime, 250)\n  this.ticks = 0\n  this.initParticles()\n}\n\nParticleEmitter.prototype = {\n  tick: function() {\n    if( this.ticks++ >= this.lifetime) \n      this.entity.kill()\n  },\n  initParticles: function() {\n    for(var i = 0 ; i < this.amount ; i++) {\n      var velx = 1.0 - Math.random() * 2.0;\n      var vely = 1.0 - Math.random() * 2.0;\n      var size = 10.0 + Math.random() * 10.0;\n      var r = Math.random() * (this.r * 255) >> 0;\n      var g = Math.random() * (this.g * 255) >> 0;\n      var b = Math.random() * (this.b * 255) >> 0;\n      var colour = \"rgba(\"+r+\",\"+g+\",\"+b+\",0.5)\";\n      this.particles.push({\n        x: this.entity.x,\n        y: this.entity.y,\n        velx: velx,\n        vely: vely,\n        size: size,\n        colour: colour\n      })\n    }\n  },\n  render: function(context) { \n    context.save();\n    context.globalAlpha = Math.max(1.0 - (this.ticks / this.lifetime, 0.0));\n    for(var i = 0; i < this.amount ; i++) {\n      var particle = this.particles[i];\n      this.updateParticle(particle);\n\n      context.beginPath();\n      var gradient = context.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size);\n      gradient.addColorStop(0, \"white\");\n      gradient.addColorStop(0.1, \"white\");\n      gradient.addColorStop(0.1, particle.colour);\n      gradient.addColorStop(1, \"transparent\");\n      context.fillStyle = gradient;\n      context.arc(particle.x, particle.y, particle.size, Math.PI * 2, false);\n      context.fill();\n    }\n    context.restore();\n  },\n  updateParticle: function(particle) {\n    particle.x += particle.velx;\n    particle.y += particle.vely;\n  }\n}\n\nmodule.exports = ParticleEmitter\n\n//@ sourceURL=/site/components/particleemitter.js"
));

require.define("/site/entities/scorekeeper.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n\nvar ScoreKeeper = Primo.DefineEntity(function(id, data) {\n  var score = 0\n    , level = 1\n    , multiplier = 1\n    , keeper = this\n\n  this.scene.on('damaged', function() {\n    multiplier = 1\n  })\n  this.scene.on('asteroid-destroyed', function() {\n    score += level * multiplier\n    multiplier++\n    keeper.raise('score-changed', score)\n  })\n\n})\n\nmodule.exports = ScoreKeeper\n\n//@ sourceURL=/site/entities/scorekeeper.js"
));

require.define("/site/entities/poweruplistener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n\nvar Asteroid = require('./asteroid')\nvar Powerup = require('./powerup')\nvar FloatingText = require('./floatingtext')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var scene = this.scene\n  scene.on('asteroid-destroyed', function(asteroid) {\n    trySpawnPowerupFor(asteroid)\n  })\n  scene.on('powerup-collected', function(powerup) {\n    scene.spawnEntity(FloatingText, {\n      x: powerup.x,\n      y: powerup.y,\n      text: powerup.name,\n      time: 3\n    })\n  })\n})\n\nfunction trySpawnPowerupFor(asteroid) {\n  if(Math.random() < 0.4) \n    spawnPowerupFor(asteroid)\n}\n\nfunction spawnPowerupFor(asteroid) {\n  asteroid.scene.spawnEntity(Powerup, {\n    x: asteroid.x + asteroid.width/2,\n    y: asteroid.y + asteroid.height/2,\n    rotvel: 3 // Biblical \"PI\" ;-)\n  })\n}\n\n//@ sourceURL=/site/entities/poweruplistener.js"
));

require.define("/site/entities/destructionfield.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n  , Asteroid = require('./asteroid')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.attach({\n    entity: this,\n    radius: 0,\n    tick: function() {\n      this.radius += 10\n      if(this.radius > 1000)\n        this.entity.kill()\n    },\n    render: function(context) {\n      context.save()\n      context.globalAlpha = 0.2\n      context.fillStyle = '#505'\n      context.beginPath();\n      context.arc(this.entity.x, this.entity.y, this.radius, 0, Math.PI*2, true); \n      context.closePath();\n      context.fill();\n      context.restore()\n    }\n  })\n  this.scene.forEachVisibleEntity(function(entity) {\n    if(entity instanceof Asteroid)\n      entity.kill()\n  })\n})\n\n//@ sourceURL=/site/entities/destructionfield.js"
));

require.define("/site/entities/floatingtext.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Text = require('primo-text')\nvar Primo = require('primo')\n\nvar TimedRemoval = require('../components/timedremoval')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.height = 60\n  this.vely = -60\n  this.attach(new Text(this, data.text, '#FFF'))\n  this.attach(new TimedRemoval(this, data.time))\n})\n\n//@ sourceURL=/site/entities/floatingtext.js"
));

require.define("/node_modules/primo-text/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"text.js\"}\n//@ sourceURL=/node_modules/primo-text/package.json"
));

require.define("/node_modules/primo-text/text.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Text = function(entity, text, colour) {\n  this.entity = entity\n  this.text = text\n  this.colour = colour || '#FFF'\n}\n\nText.prototype = {\n  render: function(context) {\n    context.fillStyle = this.colour\n    context.font = this.entity.height + 'px sans-serif'\n    context.fillText(this.text, this.entity.x, this.entity.y)\n  },\n  display: function(text) {\n    this.text = text\n  }\n}\n\nmodule.exports = Text\n\n//@ sourceURL=/node_modules/primo-text/text.js"
));

require.define("/site/components/timedremoval.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var TimedRemoval = function(entity, time) {\n  this.time = time\n  this.entity = entity\n  this.totalsofar = 0\n}\n\nTimedRemoval.prototype = {\n  tick: function(frameTime) {\n    this.totalsofar += frameTime\n    if(this.totalsofar >= this.time)\n      this.entity.kill()\n  }\n}\n\nmodule.exports = TimedRemoval\n\n//@ sourceURL=/site/components/timedremoval.js"
));

require.define("/site/entities/hud.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar ui = require('primo-ui')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var health = this.game.ui.add(new ui.Rect({\n    x: 10,\n    y: 460,\n    height: 8,\n    width: 620,\n    colour: '#0F0'\n  }))\n  var energy = this.game.ui.add(new ui.Rect({\n    x: 10,\n    y: 470,\n    height: 8,\n    width: 620,\n    colour: '#FF0'\n  }))\n  var score = this.game.ui.add(new ui.Label({\n    x: 10,\n    y: 10,\n    height: 18,\n    font: 'sans-serif',\n    colour: '#FFF',\n    text: 'Score: 0'\n  }))\n  var level = this.game.ui.add(new ui.Label({\n    x: 320,\n    y: 160,\n    align: \"center\",\n    height: 50,\n    font: 'comic sans',\n    colour: 'FFF',\n    text: 'Level 0'\n  }))\n  level.hide()\n\n  this.scene.on('health-changed', function(current, planet) {\n    var max = planet.health.max\n      , percentage = current / max\n    health.width = 620 * percentage\n  })\n  this.scene.on('energy-changed', function(current, defender) {\n    var maxEnergy = defender.firingControl.maxEnergy\n      , percentage = current / maxEnergy\n    energy.width = 620 * percentage\n  })\n  this.scene.on('infinite-energy-activated', function() {\n    energy.colour = '#00F'\n  })\n  this.scene.on('infinite-energy-deactivated', function() {\n    energy.colour = '#FF0'\n  })\n  this.scene.on('score-changed', function(current) {\n    score.text = 'Score: ' + current\n  })\n\n  this.scene.on('level-changed', function(current) {\n    level.text = \"Level \" + current\n    level.show()\n    this.game.scheduleEvent(hideLevel, 2000)\n  })\n\n  function hideLevel() {\n    level.hide()\n  }\n})\n\n//@ sourceURL=/site/entities/hud.js"
));

require.define("/site/menu.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var menu = require('primo-menu')\nvar ui = require('primo-ui')\nvar _ = require('underscore')\n\nvar Menu = function(engine, game) {\n  this.game = game\n  this.engine = engine\n  _.bindAll(this)\n}\n\nMenu.prototype = {\n  startGame: function() {\n    this.engine.menu.hide()\n    this.game.start()\n  },\n  index: function() {\n    this.engine.menu.show()\n      .addOption(new ui.Label({\n        text: \"Play\",\n        x: 290,\n        y: 140,\n        height: 32,\n        font: 'comic sans',\n        colour: '#FFF'\n      }), this.startGame)\n      .addOption(new ui.Label({\n        text: \"Instructions\",\n        x: 290,\n        y: 260,\n        height: 32,\n        font: 'comic sans',\n        colour: '#FFF'\n      }), this.instructions)\n  },\n  instructions: function() {\n    this.engine.menu.show()\n      .addOption(new ui.Label({\n        text: \"Back\",\n        x: 320,\n        y: 260,\n        align: 'center',\n        height: 32,\n        font: 'comic sans',\n        colour: '#FFF'\n    }), this.index)\n    .addDisplay(new ui.Label({\n        text: \"You are defending the world, go you\",\n        x: 50,\n        y: 50,\n        height: 16,\n        font: 'comic sans',\n        colour: '#FFF'\n    }))\n    .addDisplay(new ui.Label({\n        text: \"Use the arrow keys to move the defender\",\n        x: 50,\n        y: 70,\n        height: 16,\n        font: 'comic sans',\n        colour: '#FFF'\n    }))\n    .addDisplay(new ui.Label({\n        text: \"Use the ctrl key to fire\",\n        x: 50,\n        y: 90,\n        height: 16,\n        font: 'comic sans',\n        colour: '#FFF'\n    }))\n    .addDisplay(new ui.Label({\n        text: \"Mind you don't run out of energy though!\",\n        x: 50,\n        y: 110,\n        height: 16,\n        font: 'comic sans',\n        colour: '#FFF'\n    }))\n  },\n  gameover: function() {\n    this.engine.menu.show()\n      .addOption(new ui.Label({\n        text: \"Play again\",\n        x: 260,\n        y: 200,\n        height: 32,\n        font: 'comic sans',\n        colour: '#FFF'\n      }), this.startGame)\n      .addDisplay(new ui.Label({\n        text: \"Game over\",\n        x: 320,\n        y: 50,\n        align: 'center',\n        height: 50,\n        font: 'comic sans',\n        colour: '#FFF'\n      }))\n      .addDisplay(new ui.Label({\n        text: \"Thanks for playing\",\n        x: 320,\n        y: 110,\n        align: 'center',\n        height: 16,\n        font: 'comic sans',\n        colour: '#FFF'\n      }))\n  }\n}\nmodule.exports = Menu\n\n//@ sourceURL=/site/menu.js"
));

require.define("/site/entities/powerup.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar Animation = require('primo-animation')\nvar RigidBody = require('primo-physics').RigidBody\n\nvar Defender = require('./defender')\nvar Planet = require('./planet')\nvar DestructionField = require('./destructionfield')\nvar EnergyFeeder = require('./energyfeeder')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var powerup = powerups[Math.floor(Math.random() * powerups.length)]\n  this.width = 50\n  this.height = 50\n  this.gravible = true\n  this.name = powerup.name,\n  this.attach(new Animation(this, powerup.texture))\n  this.attach(new RigidBody(this, {\n    solid: false,\n    type: \"circle\"\n  }))\n  this.on('collided', function(other) {\n    if(other instanceof Defender) {\n      this.raise('powerup-collected', this)\n      powerup.invoke.call(this)\n      this.kill()\n    }\n    else if(other instanceof Planet)\n      this.kill()\n  })\n})\n\nvar powerups = [\n  {\n    name: \"Energy boost!\",\n    texture: 'media/star.png',\n    invoke: function() {\n      var defender = this.scene.findEntityById('defender')\n      defender.firingControl.modifyEnergy(100)\n    }\n  },\n  {\n    name: \"Health boost!\",\n    texture: 'media/heart.png',\n    invoke: function() {\n      var planet = this.scene.findEntityById('planet')\n      planet.health.increase(50)\n    }\n  },\n  {\n    name: \"Destruction field!\",\n    texture: 'media/destruction.png',\n    invoke: function() {\n      var planet = this.scene.findEntityById('planet')\n      this.scene.spawnEntity(DestructionField, {\n        x: planet.x + planet.width/2,\n        y: planet.y + planet.height/2\n      })\n    }\n  },\n  {\n    name: \"Energy regen!\",\n    texture: 'media/infinite.png',\n    invoke: function() {\n      this.scene.spawnEntity(EnergyFeeder)\n    }\n  }\n]\n\n//@ sourceURL=/site/entities/powerup.js"
));

require.define("/site/entities/asteroid.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar Animation = require('primo-animation')\nvar RigidBody = require('primo-physics').RigidBody\nvar TimedRemoval = require('../components/timedremoval')\n\n\nvar Planet = require('./planet')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.width = 40 + Math.random() * 50;\n  this.height = this.width\n  this.gravible = true\n  this.attach(new Animation(this, 'media/asteroid.png'))\n  this.attach(new TimedRemoval(this, 60))\n  this.attach(new RigidBody(this, {\n    weight: 90 - (90 / this.width),\n    bounce: 0.5,\n    type: \"circle\"\n  }))\n\n  this.on('collided', function(other) {\n     if(other instanceof Planet) {\n       other.dispatch('damage', 10)\n       this.kill()\n     }\n  })\n})\n\n\n//@ sourceURL=/site/entities/asteroid.js"
));

require.define("/site/entities/bullet.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar GradientCircle = require('../components/gradientcircle')\nvar RigidBody = require('primo-physics').RigidBody\nvar Asteroid = require('./asteroid')\nvar TimedRemoval = require('../components/timedremoval')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  this.width = 5 + Math.min(data.power * 0.5, 10)\n  this.height = 5 + Math.min(data.power * 0.5, 10)\n  this.attach(new GradientCircle(this, '#FFF', '#0F0', '#000'))\n  this.attach(new TimedRemoval(this, 30))\n\n  this.attach(new RigidBody(this, {\n    solid: false,\n    gravity: 0.0,\n    bounce: 0.0\n  }))\n\n  var bullet = this\n  this.on('collided', function(other) {\n    if(other instanceof Asteroid) {\n      this.raise('asteroid-destroyed', other)\n      other.kill()\n      bullet.kill()\n    }\n  })\n})\n\n\n//@ sourceURL=/site/entities/bullet.js"
));

require.define("/site/variables.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\n  init: function(engine) {\n    engine.variables = new TinyDefenderVariables(engine)\n  }\n}\n\nvar TinyDefenderVariables = function(engine) {\n  this.engine = engine\n  this.scene = engine.scene\n  this.scene.on('level-changed', this.onLevelChanged, this)\n  this.spawnTime = 0\n  this.speedSeed = 0\n  this.firingConsumption = 50\n  this.firingRegen = 1\n  this.firingRate = 10\n  this.bulletSpeed = 90\n}\n\nTinyDefenderVariables.prototype = {\n  onLevelChanged: function(level) {\n    this.spawnTime = Math.max(2500 - (level * 100), 500)\n    this.speedSeed = Math.min(50 + (level * 10), 100)\n    this.firingConsumption = 10\n    this.firingRegen = 0.4\n    this.firingRate = 10\n    this.bulletSpeed = 90\n  }\n}\n\n//@ sourceURL=/site/variables.js"
));

require.define("/site/entities/energyfeeder.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar TimedRemoval = require('../components/timedremoval')\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var active = false\n  this.attach(new TimedRemoval(this, 5))\n\n  this.on('tick', function() {\n    if(!active) {\n      this.raise('infinite-energy-activated')\n      active = true\n    }\n    var defender = this.scene.findEntityById('defender')\n    defender.firingControl.modifyEnergy(10)\n  })\n\n  this.on('killed', function() {\n    this.raise('infinite-energy-deactivated')\n  })\n})\n\n\n\n//@ sourceURL=/site/entities/energyfeeder.js"
));

require.define("/site/components/firingcontrol.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Bullet = require('../entities/bullet')\n\nvar FiringControl = function(entity) {\n  this.entity = entity\n  this.firingTicks = 0\n  this.energy = 100\n  this.maxEnergy = 100\n  this.power = 1\n  this.game = entity.game\n  this.scene = this.game.scene\n  this.variables = this.game.variables\n  this.entity.firingControl = this\n  this.scene.on('asteroid-destroyed', this.onAsteroidDestroyed, this)\n  this.scene.on('damaged', this.onPlanetDamaged, this)\n}\n\nFiringControl.prototype = {\n  tick: function() {\n    this.regen()\n    this.updateFiringTicks()\n    if(this.energy >= this.variables.firingConsumption && this.game.input.active('fire')) \n      this.tryFire()\n  },\n  tryFire: function() {\n    if(this.firingTicks === 0)\n      this.fire()\n  },\n  fire: function() {\n    var xcom = Math.cos(this.entity.rotation)\n      , ycom = Math.sin(this.entity.rotation)\n    var velx = this.variables.bulletSpeed * xcom\n    var vely = this.variables.bulletSpeed * ycom\n    this.scene.spawnEntity(Bullet, {\n      x: this.entity.x + xcom * 10,\n      y: this.entity.y + ycom * 10,\n      velx: velx,\n      vely: vely,\n      power: this.power\n    })\n    this.firingTicks++\n    this.modifyEnergy(-this.variables.firingConsumption)\n    this.entity.raise('fired')\n  },\n  modifyEnergy: function(amount) {\n    this.energy += amount\n    if(this.energy > this.maxEnergy)\n      this.energy = this.maxEnergy\n    if(this.energy < 0) this.energy = 0\n    this.entity.raise('energy-changed', this.energy)\n  },\n  regen: function() {\n    if(this.energy < this.maxEnergy)\n      this.modifyEnergy(this.variables.firingRegen)\n  },\n  updateFiringTicks: function() {\n    if(this.firingTicks === 0) return\n    if(++this.firingTicks === this.variables.firingRate)\n      this.firingTicks = 0\n  },\n  onAsteroidDestroyed: function() {\n    this.power++\n  },\n  onPlanetDamaged: function() {\n    this.power = 1\n  }\n}\n\nmodule.exports = FiringControl\n\n//@ sourceURL=/site/components/firingcontrol.js"
));

require.define("/site/game.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Planet = require('./entities/planet')\nvar Defender = require('./entities/defender')\nvar AsteroidSpawner = require('./entities/asteroidspawner')\nvar ExplosionListener = require('./entities/explosionlistener')\nvar ScoreKeeper = require('./entities/scorekeeper')\nvar PowerupListener = require('./entities/poweruplistener')\nvar Sounds = require('./entities/audio')\nvar Hud = require('./entities/hud')\nvar Eventable = require('primo-events')\nvar _ = require('underscore')\n\nvar TinyDefender = function(engine) {\n  Eventable.call(this)\n  this.engine = engine\n  this.scene = engine.scene\n  this.engine.input.bind(engine.input.LEFT_ARROW, 'left')\n  this.engine.input.bind(engine.input.RIGHT_ARROW, 'right')\n  this.engine.input.bind(engine.input.LEFT_CTRL, 'fire')\n  this.engine.gravity = this.gravity \n  this.level = 0\n  this.asteroidsDestroyed = 0\n}\n\nTinyDefender.prototype = {\n  start: function() {\n    this.level = 0\n    this.asteroidsDestroyed = 0\n\n    var engine = this.engine\n      , scene = engine.scene\n      , camera = scene.camera\n      , planet = scene.spawnEntity(Planet, {\n          x: 0,\n          y: 0,\n          radius: 128\n      })\n      , defender = scene.spawnEntity(Defender, {\n          centrex: 0,\n          centrey: 0,\n          radius: 160\n      })\n      , spawner = scene.spawnEntity(AsteroidSpawner)\n      , explosions = scene.spawnEntity(ExplosionListener)\n      , powerups = scene.spawnEntity(PowerupListener)\n      , hud = scene.spawnEntity(Hud)\n      , scores = scene.spawnEntity(ScoreKeeper)\n      , sounds = scene.spawnEntity(Sounds)\n\n    engine.cellsize = 100\n    camera.moveTo(0,0)\n    camera.zoomTo(2000)\n    scene.on('player-died', this.onPlayerDied, this)\n    scene.on('asteroid-destroyed', this.onAsteroidDestroyed, this)\n    this.changeLevel(1)\n  },\n  changeLevel: function(level) {\n    this.level = level\n    this.scene.raise('level-changed', level)\n  },\n  onAsteroidDestroyed: function() {\n    this.asteroidsDestroyed++\n    if(this.asteroidsDestroyed % 5 === 0)\n      this.changeLevel(this.level+1)\n  },\n  onPlayerDied: function() {\n    var game = this\n    setTimeout(function() {\n      game.engine.ui.clear()\n      game.raise('game-over')\n      game.engine.reset()\n    }, 2000)\n  },\n  gravity: function(entity, result) {\n    var mag = Math.sqrt(entity.x*entity.x + entity.y*entity.y)\n    result.x = (-entity.x / mag) * 0.2 \n    result.y = (-entity.y / mag) * 0.2\n  }\n}\n_.extend(TinyDefender.prototype, Eventable.prototype)\n\nmodule.exports = TinyDefender\n\n\n  \n\n//@ sourceURL=/site/game.js"
));

require.define("/site/entities/audio.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\n\n\nmodule.exports = Primo.DefineEntity(function(id, data) {\n  var shoot = this.game.resources.sound('media/shoot')\n  var pickup = this.game.resources.sound('media/pickup')\n  var splosion = this.game.resources.sound('media/explosion')\n\n  this.scene.on('fired', function() {\n    shoot.play()\n  })\n  this.scene.on('powerup-collected', function() {\n    pickup.play()\n  })\n\n  this.scene.on('asteroid-destroyed', function() {\n    splosion.play()\n  })\n\n  this.scene.on('damaged', function() {\n    splosion.play()\n  })\n})\n\n//@ sourceURL=/site/entities/audio.js"
));

require.define("/site/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Primo = require('primo')\nvar PrimoPhysics = require('primo-physics')\nvar PrimoMenu = require('primo-menu')\nvar PrimoUi = require('primo-ui')\n\nvar TinyDefender = require('./game')\nvar TinyDefenderMenu = require('./menu')\nvar TinyDefenderVariables = require('./variables')\n\nvar engine = Primo.Create('game')\nvar game = new TinyDefender(engine)\nvar menu = new TinyDefenderMenu(engine, game)\n\ngame.on('game-over', function() {\n  menu.gameover()\n})\n\nengine.on('init', function() {\n  PrimoPhysics.init(engine)\n  PrimoUi.init(engine, { width: 640, height: 480 })\n  PrimoMenu.init(engine)\n  TinyDefenderVariables.init(engine)\n  menu.index()\n})\nengine.start()\n\nengine.render = function() {\n  this.context.globalCompositionOperation = 'source-over';\n  this.context.fillStyle = 'rgba(0, 0, 0, 0.1)';\n  this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  this.context.globalCompositionOperation = 'lighter';\n  this.scene.render(this.context)\n  this.raise('render', this.context)\n}\n\n//@ sourceURL=/site/main.js"
));
require("/site/main.js");
})();
